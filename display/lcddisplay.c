/*****************************************************************************
* CODE OWNERSHIP AND DISCLAIMER OF LIABILITY
*
* Microchip Technology Incorporated ("Microchip") retains all ownership and
* intellectual property rights in the code accompanying this message and in
* all derivatives hereto.  You may use this code, and any derivatives created
* by any person or entity by or on your behalf, exclusively with Microchip’s
* proprietary products.  Your acceptance and/or use of this code constitutes
* agreement to the terms and conditions of this notice.
*
* CODE ACCOMPANYING THIS MESSAGE IS SUPPLIED BY MICROCHIP "AS IS".  NO
* WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT
* LIMITED TO, IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS CODE, ITS INTERACTION WITH
* MICROCHIP’S PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
* APPLICATION.
*
* YOU ACKNOWLEDGE AND AGREE THAT, IN NO EVENT, SHALL MICROCHIP BE LIABLE,
* WHETHER IN CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE OR BREACH OF
* STATUTORY DUTY), STRICT LIABILITY, INDEMNITY, CONTRIBUTION, OR OTHERWISE,
* FOR ANY INDIRECT, SPECIAL, PUNITIVE, EXEMPLARY, INCIDENTAL OR CONSEQUENTIAL
* LOSS, DAMAGE, FOR COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
* CODE, HOWSOEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
* POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.  TO THE FULLEST EXTENT ALLOWABLE
* BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS
* CODE, SHALL NOT EXCEED THE PRICE YOU PAID DIRECTLY TO MICROCHIP SPECIFICALLY
* TO HAVE THIS CODE DEVELOPED.
*
* You agree that you are solely responsible for testing the code and
* determining its suitability.  Microchip has no obligation to modify, test,
* certify, or support the code.
*
* Author                Date        Comment
*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* name                  11/17/11    ...
******************************************************************************/
/*! \file lcddisplay.c
	\brief lcd implementation for a basic lcd panel.

	This file handles all functionality of the lcd display.  This implementation
	uses a EA DOGL128x-9 with no backlight.
*/
#include "display\lcddisplay.h"
#ifdef DISPLAY

extern TOUCHIDSET touchIDSet;

unsigned char guiTemp[4][32];
LCDBUFFER lcdBuffer;
LCDTOUCHLOC touchLocs;

// Initialization string for the lcd screen
static const unsigned char lcdInitString[] = {0x40,0xA1,0xC0,0xA6,0xA2,0x2F,0xF8,0x00,0x27,0x81,0x10,0xAC,0x00,0xAF};


// Microchip logo that fills the screen
ROM_DATA BYTE lcdBaseScreen[8][128] = {  // Microchip Logo
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xE0,0xF0,0xF8,0xF8,0xFC,0xFC,0xFE,0xFE,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
	 0xFF,0xFF,0xFF,0xFF,0xFE,0xFE,0xFE,0xFE,0xFC,0xF8,0xE0,0xC0,0x00,0x00,0x38,0x44,0xBE,0x96,0xAA,0x44,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF8,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x1F,0x0F,0x03,0x01,0x00,0x00,0x01,0x03,0x0F,0x1F,0x7F,0xFF,0xFF,
	 0xFF,0xFF,0x1F,0x0F,0x07,0x01,0x00,0x00,0x01,0x03,0x0F,0x1F,0x7F,0xFC,0xF8,0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0xFF,0xFF,0x7F,0x1F,0x0F,0x07,0x03,0x0F,0x3F,0x7E,0xF8,0xF0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,
	 0x0F,0x1F,0x7E,0xFC,0xF0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x07,0x1F,0x7F,0xFE,0xF8,0xF0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,0xF0,0xFF,0xFF,0xFF,0xFE,0xF8,0xF0,0xC0,0x80,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x81,0xE3,0xFF,0xFF,0xFE,0xFC,0xF0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x1C,0x3F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,
	 0xF8,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x7E,0x3C,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0xE0,0xF0,0xF0,0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,0xF0,0xF0,0xF0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x03,0x03,0x03,0x03,0x03,0x07,0x07,0x07,
	 0x07,0x07,0x03,0x03,0x03,0x03,0x03,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0xFE,0xFF,0xFF,0x7F,0x1F,0xFF,0xFE,0xF8,0xE0,0x00,0x80,0xF0,0xFC,0xFF,0x7F,0x0F,0xFF,0xFF,0xFF,0x80,0x00,0x00,0xFE,0xFE,0xFE,0xFE,0x00,0x00,0xF8,
	 0xFE,0xFE,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1C,0x00,0x00,0xFE,0xFE,0xFE,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0xFE,0xFE,0xF8,0x00,0x00,0xFC,0xFE,0xFE,
	 0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0xFE,0xFE,0xFC,0xE0,0x00,0xF0,0xFC,0xFE,0x7E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x00,0x00,0xFE,0xFE,0xFE,0xC0,0xC0,
	 0xC0,0xC0,0xC0,0xC0,0xC0,0xFE,0xFE,0xFE,0x00,0x00,0xFE,0xFE,0xFE,0xFE,0x00,0x00,0xFE,0xFE,0xFE,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0xFE,0xFE,0xF8,0x00,0x00,0x00},
	{0x00,0x00,0xF8,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x07,0x3F,0x7F,0x7F,0x7F,0x3F,0x0F,0x01,0x00,0x00,0x07,0xFF,0xFF,0xFF,0x80,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x3F,
	 0x7F,0xFF,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0x70,0x00,0x00,0xFF,0xFF,0xFF,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x1F,0xFF,0xFF,0xF9,0x00,0x00,0x7F,0xFF,0xFF,
	 0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xFF,0xFF,0x7F,0x0F,0x00,0x1F,0x7F,0xFF,0xFC,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0x10,0x00,0xFF,0xFF,0xFF,0x03,0x03,
	 0x03,0x03,0x03,0x03,0x03,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x03,0x00,0x00,0x00}};

// "Glyphs" are graphics/icons that can be placed at various locations on the sensor
// When placing a glyph it is possible to place a subset of the glyph at a location
// this allows us to have a font in a single glyph.
// Comments in-line are (offset) NAME (dimensions) = size
#ifndef USE_SMALL_ICONS
	ROM_DATA BYTE glyphData[] = {
		// (0) GLYPH_FONT (128 x 24) = 384 bytes
		0x00,0x00,0x00,0x00,0x00,0x2E,0x00,0x00,0x06,0x00,0x06,0x00,0x3E,0x14,0x3E,0x00,0x14,0x3E,0x0A,0x00,0x12,0x08,0x24,0x00,0x1E,0x2E,0x38,0x00,0x00,0x06,0x00,0x00,
		0x00,0x1C,0x22,0x00,0x22,0x1C,0x00,0x00,0x0A,0x04,0x0A,0x00,0x08,0x1C,0x08,0x00,0x20,0x10,0x00,0x00,0x08,0x08,0x08,0x00,0x00,0x20,0x00,0x00,0x30,0x08,0x06,0x00,
		0x3C,0x22,0x1E,0x00,0x04,0x3E,0x00,0x00,0x32,0x2A,0x24,0x00,0x22,0x2A,0x14,0x00,0x0E,0x08,0x3E,0x00,0x2E,0x2A,0x12,0x00,0x3C,0x2A,0x3A,0x00,0x32,0x0A,0x06,0x00,
		0x3E,0x2A,0x3E,0x00,0x2E,0x2A,0x1E,0x00,0x00,0x14,0x00,0x00,0x20,0x14,0x00,0x00,0x08,0x14,0x22,0x00,0x14,0x14,0x14,0x00,0x22,0x14,0x08,0x00,0x02,0x2A,0x06,0x00,
		0x1C,0x2A,0x2C,0x00,0x3C,0x0A,0x3C,0x00,0x3E,0x2A,0x14,0x00,0x1C,0x22,0x22,0x00,0x3E,0x22,0x1C,0x00,0x3E,0x2A,0x2A,0x00,0x3E,0x0A,0x0A,0x00,0x1C,0x2A,0x3A,0x00,
		0x3E,0x08,0x3E,0x00,0x22,0x3E,0x22,0x00,0x10,0x20,0x1E,0x00,0x3E,0x08,0x36,0x00,0x3E,0x20,0x20,0x00,0x3E,0x0C,0x3E,0x00,0x3E,0x1C,0x3E,0x00,0x1C,0x22,0x1C,0x00,
		0x3E,0x0A,0x04,0x00,0x1C,0x32,0x3C,0x00,0x3E,0x1A,0x2C,0x00,0x24,0x2A,0x12,0x00,0x02,0x3E,0x02,0x00,0x1E,0x20,0x3E,0x00,0x0E,0x30,0x0E,0x00,0x3E,0x18,0x3E,0x00,
		0x36,0x08,0x36,0x00,0x06,0x38,0x06,0x00,0x32,0x2A,0x26,0x00,0x3E,0x22,0x22,0x00,0x04,0x08,0x10,0x00,0x22,0x22,0x3E,0x00,0x04,0x02,0x04,0x00,0x20,0x20,0x20,0x00,
		0x02,0x04,0x00,0x00,0x34,0x2C,0x38,0x00,0x3E,0x24,0x18,0x00,0x18,0x24,0x24,0x00,0x18,0x24,0x3E,0x00,0x18,0x34,0x2C,0x00,0x08,0x3C,0x0A,0x00,0x18,0x54,0x3C,0x00,
		0x3E,0x04,0x38,0x00,0x00,0x3A,0x00,0x00,0x20,0x40,0x3A,0x00,0x3E,0x18,0x24,0x00,0x22,0x3E,0x20,0x00,0x3C,0x1C,0x3C,0x00,0x3C,0x04,0x38,0x00,0x18,0x24,0x18,0x00,
		0x7C,0x24,0x18,0x00,0x18,0x24,0x7C,0x00,0x38,0x04,0x04,0x00,0x28,0x3C,0x14,0x00,0x04,0x3E,0x24,0x00,0x1C,0x20,0x3C,0x00,0x1C,0x30,0x1C,0x00,0x3C,0x38,0x3C,0x00,
		0x24,0x18,0x24,0x00,0x0C,0x50,0x3C,0x00,0x34,0x3C,0x2C,0x00,0x08,0x36,0x22,0x00,0x00,0x36,0x00,0x00,0x22,0x36,0x08,0x00,0x04,0x06,0x02,0x00,0x3E,0x3E,0x3E,0x00,
		// (384) GLYPH_SMILE, GLYPH_FROWN, GLYPH_HATCH, GLYPH_GHOST, GLYPH_FACE_MASK, GLYPH_GHOST_MASK = 44 bytes
		0x3C,0x42,0x95,0xA1,0xA1,0x95,0x42,0x3C,0x3C,0x42,0xA5,0x91,0x91,0xA5,0x42,0x3C,0x24,0x49,0x92,0x24,0x49,0x92,0x24,0x49,0xFE,0x41,0x8D,0x4D,0x81,0x7E,0xC3,0x81,
		0x00,0x00,0x00,0x00,0x81,0xC3,0x01,0x80,0x00,0x80,0x00,0x81,
		// (428) GLYPH_SWIPE_RIGHT = 128 bytes
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFE,0x1C,0x38,0x70,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0xFF,0xFF,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x00,0x00,0x00,0x00,0x01,0x03,0x07,0x0E,0x1C,0x38,0x70,0xE0,0xC0,0x80,
		0xFF,0xFF,0xD0,0xC4,0xD0,0xC4,0xD0,0xC4,0xD0,0xC4,0xD0,0xC4,0xD0,0xC4,0xD0,0xC4,0xD0,0xC4,0x10,0x44,0x10,0x44,0x90,0xC4,0xE0,0x74,0x38,0x1C,0x0E,0x07,0x03,0x01,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x7F,0x38,0x1D,0x0E,0x07,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		// (556) GLYPH SWIPE_RIGHT_HOLD = 128 bytes
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFE,0x1C,0x38,0x70,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0xFF,0xFF,0x03,0x03,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF0,0xFF,0xFE,0xEC,0xD9,0xB3,0xE7,0xCE,0x9C,0x38,0x70,0xE0,0xC0,0x80,
		0xFF,0xFF,0xC0,0xC0,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0x0F,0xFF,0x7F,0x3F,0x9F,0xCF,0xE7,0x73,0x39,0x1C,0x0E,0x07,0x03,0x01,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x7F,0x38,0x1C,0x0E,0x07,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		// (684) GLYPH_SWIPE_RIGHT_MASK = 128 bytes
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		// (812) GLYPH_SWIPE_LEFT = 128 bytes
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x1C,0xFE,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x80,0xC0,0xE0,0x70,0x38,0x1C,0x0E,0x07,0x03,0x01,0x00,0x00,0x00,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0xFF,0xFF,
		0x01,0x03,0x07,0x0E,0x1C,0x38,0x74,0xE0,0xC4,0x90,0x44,0x10,0x44,0x10,0xC4,0xD0,0xC4,0xD0,0xC4,0xD0,0xC4,0xD0,0xC4,0xD0,0xC4,0xD0,0xC4,0xD0,0xC4,0xD0,0xFF,0xFF,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x07,0x0E,0x1D,0x38,0x7F,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		// (940) GLYPH_SWIPE_LEFT_HOLD = 128 bytes
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x1C,0xFE,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x80,0xC0,0xE0,0x70,0x38,0x9C,0xCE,0xE7,0xB3,0xD9,0xEC,0xFE,0xFF,0xF0,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0x03,0x03,0xFF,0xFF,
		0x01,0x03,0x07,0x0E,0x1C,0x39,0x73,0xE7,0xCF,0x9F,0x3F,0x7F,0xFF,0x0F,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xC0,0xC0,0xFF,0xFF,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x07,0x0E,0x1C,0x38,0x7F,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		// (1068) GLYPH_SWIPE_LEFT_MASK = 128 bytes
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x3F,0x1F,0x0F,0x07,0x03,0x01,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0x7F,0x3F,0x1F,0x0F,0x07,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		// (1196) GLYPH_SWIPE_UP = 128 bytes
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x1C,0x0E,0x07,0x07,0x0E,0x1C,0x38,0x70,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x80,0xC0,0xE0,0xF0,0xF8,0xDC,0xCE,0xC7,0xC3,0xC1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC1,0xC3,0xC7,0xCE,0xDC,0xF8,0xF0,0xE0,0xC0,0x80,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xC8,0xE2,0xC8,0xE2,0xC8,0xE2,0xC8,0xE2,0xC8,0xE2,0xC8,0xE2,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		// (1324) GLYPH_SWIPE_UP_HOLD = 128 bytes
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x9C,0xCE,0xE7,0xE7,0xCE,0x9C,0x38,0x70,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x80,0xC0,0xE0,0xF0,0xF8,0xDC,0xCE,0xC7,0xD3,0xD9,0x1C,0x1E,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFD,0xFB,0x1E,0x1C,0xD9,0xD3,0xC7,0xCE,0xDC,0xF8,0xF0,0xE0,0xC0,0x80,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xC0,0xC0,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xC0,0xC0,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		// (1452) GLYPH_SWIPE_UP_MASK = 128 bytes
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x3F,0x1F,0x0F,0x07,0x03,0x01,0x00,0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0x7F,0x3F,0x1F,0x0F,0x07,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		// (1580) GLYPH_SWIPE_DOWN = 128 bytes
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x47,0x13,0x47,0x13,0x47,0x13,0x47,0x13,0x47,0x13,0x47,0x13,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x01,0x03,0x07,0x0F,0x1F,0x3B,0x73,0xE3,0xC3,0x83,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x83,0xC3,0xE3,0x73,0x3B,0x1F,0x0F,0x07,0x03,0x01,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x07,0x0E,0x1C,0x38,0x70,0xE0,0xE0,0x70,0x38,0x1C,0x0E,0x07,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		// (1708) GLYPH_SWIPE_DOWN_HOLD = 128 bytes
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x03,0x03,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0x03,0x03,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x01,0x03,0x07,0x0F,0x1F,0x3B,0x73,0xE3,0xCB,0x9B,0x38,0x78,0xDF,0xBF,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0x78,0x38,0x9B,0xCB,0xE3,0x73,0x3B,0x1F,0x0F,0x07,0x03,0x01,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x07,0x0E,0x1C,0x39,0x73,0xE7,0xE7,0x73,0x39,0x1C,0x0E,0x07,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		// (1836) GLYPH_SWIPE_DOWN_MASK = 128 bytes
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		// (1964) GLYPH_CLICK = 128 bytes
		0x00,0x00,0x00,0x18,0x38,0x70,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x18,0x00,0x00,0x00,
		0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x01,0xE1,0x38,0x0C,0x06,0x02,0x03,0x01,0x01,0x01,0x01,0x03,0x02,0x06,0x0C,0x38,0xE1,0x01,0x80,0x80,0x80,0x80,0x80,0x80,0x00,
		0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x80,0x87,0x1C,0x30,0x60,0x40,0xC0,0x80,0x80,0x80,0x80,0xC0,0x40,0x60,0x30,0x1C,0x87,0x80,0x01,0x01,0x01,0x01,0x01,0x01,0x00,
		0x00,0x00,0x00,0x18,0x1C,0x0E,0x07,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x07,0x0E,0x1C,0x18,0x00,0x00,0x00,
		// (2092) GLYPH_CLICK_HOLD = 128 bytes
		0x00,0x00,0x00,0x18,0x38,0x70,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x18,0x00,0x00,0x00,
		0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x01,0xE1,0xF8,0xFC,0xFE,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFE,0xFC,0xF8,0xE1,0x01,0x80,0x80,0x80,0x80,0x80,0x80,0x00,
		0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x80,0x87,0x1F,0x3F,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x7F,0x3F,0x1F,0x87,0x80,0x01,0x01,0x01,0x01,0x01,0x01,0x00,
		0x00,0x00,0x00,0x18,0x1C,0x0E,0x07,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x07,0x0E,0x1C,0x18,0x00,0x00,0x00,
		// (2220) GLYPH_CLICK_MASK = 128 bytes
		0xFF,0xFF,0xC3,0x83,0x03,0x03,0x07,0x0F,0x1F,0x3F,0xFF,0xFF,0x7F,0x7F,0x00,0x00,0x00,0x00,0x7F,0x7F,0xFF,0xFF,0x3F,0x1F,0x0F,0x07,0x03,0x03,0x83,0xC3,0xFF,0xFF,
		0x3F,0x3F,0x3F,0x3F,0x3F,0x3E,0x3C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x3C,0x3E,0x3F,0x3F,0x3F,0x3F,0x3F,
		0xFC,0xFC,0xFC,0xFC,0xFC,0x7C,0x3C,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x3C,0x7C,0xFC,0xFC,0xFC,0xFC,0xFC,
		0xFF,0xFF,0xC3,0xC1,0xC0,0xC0,0xE0,0xF0,0xF8,0xFC,0xFF,0xFF,0xFE,0xFE,0x00,0x00,0x00,0x00,0xFE,0xFE,0xFF,0xFF,0xFC,0xF8,0xF0,0xE0,0xC0,0xC0,0xC1,0xC3,0xFF,0xFF,
		// (2348) GLYPH_DOUBLE_CLICK = 128 bytes
		0x00,0x00,0x00,0x18,0x38,0x70,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x18,0x00,0x00,0x00,
		0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x01,0xE1,0x38,0x0C,0xC6,0x72,0x13,0x19,0x09,0x09,0x19,0x13,0x72,0xC6,0x0C,0x38,0xE1,0x01,0x80,0x80,0x80,0x80,0x80,0x80,0x00,
		0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x80,0x87,0x1C,0x30,0x63,0x4E,0xC8,0x98,0x90,0x90,0x98,0xC8,0x4E,0x63,0x30,0x1C,0x87,0x80,0x01,0x01,0x01,0x01,0x01,0x01,0x00,
		0x00,0x00,0x00,0x18,0x1C,0x0E,0x07,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x07,0x0E,0x1C,0x18,0x00,0x00,0x00,
		// (2476) GLYPH_SLEEP = 128 bytes
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x62,0x52,0x4A,0x46,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0xE0,0xE0,0xA0,0x60,0x60,0x00,0x18,0x14,0x12,0x11,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xE0,0xF0,0xB8,0x9C,0x8E,0x87,0x83,0x81,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		// (2604) GLYPH_SLEEP_MASK = 128 bytes
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x08,0x00,0x00,0x00,0x00,0x10,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x02,0xC2,0xC0,0xC0,0xC4,0xC6,0xC7,0xFF,0xFF,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x1F,0x0F,0x07,0x03,0x01,0x20,0x30,0x38,0x3C,0x3E,0x3F,0x3F,0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		// (2732) GLYPH_HEX_FONT = 64 bytes
		0x3C,0x22,0x1E,0x00,0x04,0x3E,0x00,0x00,0x32,0x2A,0x24,0x00,0x22,0x2A,0x14,0x00,0x0E,0x08,0x3E,0x00,0x2E,0x2A,0x12,0x00,0x3C,0x2A,0x3A,0x00,0x32,0x0A,0x06,0x00,
		0x3E,0x2A,0x3E,0x00,0x2E,0x2A,0x1E,0x00,0x3C,0x0A,0x3C,0x00,0x3E,0x2A,0x14,0x00,0x1C,0x22,0x22,0x00,0x3E,0x22,0x1C,0x00,0x3E,0x2A,0x2A,0x00,0x3E,0x0A,0x0A,0x00
	};

	// Information on the glyphs in glyphData.  Each instance of the structure contains
	// {X dimension, Y dimension, offset}
	ROM_DATA GLYPHINFO glyphInfo[] = {
		{128,24,0}, // GLYPH_FONT
		{8,8,384}, // GLYPH_SMILE
		{8,8,392}, // GLYPH_FROWN
		{4,16,400}, // GLYPH_HATCH
		{6,8,408}, // GLYPH_GHOST
		{8,8,414}, // GLYPH_FACE_MASK
		{6,8,422}, // GLYPH_GHOST_MASK
		{32,32,428}, // GLYPH_SWIPE_RIGHT
		{32,32,556}, // GLYPH_SWIPE_RIGHT_HOLD
		{32,32,684}, // GLYPH_SWIPE_RIGHT_MASK
		{32,32,812}, // GLYPH_SWIPE_LEFT
		{32,32,940}, // GLYPH_SWIPE_LEFT_HOLD
		{32,32,1068}, // GLYPH_SWIPE_LEFT_MASK
		{32,32,1196}, // GLYPH_SWIPE_UP
		{32,32,1324}, // GLYPH_SWIPE_UP_HOLD
		{32,32,1452}, // GLYPH_SWIPE_UP_MASK
		{32,32,1580}, // GLYPH_SWIPE_DOWN
		{32,32,1708}, // GLYPH_SWIPE_DOWN_HOLD
		{32,32,1836}, // GLYPH_SWIPE_DOWN_MASK
		{32,32,1964}, // GLYPH_CLICK
		{32,32,2092}, // GLYPH_CLICK_HOLD
		{32,32,2220}, // GLYPH_CLICK_MASK
		{32,32,2348}, // GLYPH_DOUBLE_CLICK
		{32,32,2476}, // GLYPH_SLEEP
		{32,32,2604}, // GLYPH_SLEEP_MASK
		{64,8,2732} // GLYPH_HEX_FONT
	};

	// When overlaying data, what combination of graphic and mask is needed?
	// {Graphic Glyph, Mask Glyph}
	// A mask glyph identifies which areas to retain when drawing on an area.
	ROM_DATA GLYPHSET glyphSet[] = {
		{0,0}, // OVERLAY_NONE
		{GLYPH_SWIPE_RIGHT,GLYPH_SWIPE_RIGHT_MASK}, // OVERLAY_SWIPE_RIGHT
		{GLYPH_SWIPE_RIGHT_HOLD,GLYPH_SWIPE_RIGHT_MASK}, // OVERLAY_SWIPE_RIGHT_HOLD
		{GLYPH_SWIPE_LEFT,GLYPH_SWIPE_LEFT_MASK}, // OVERLAY_SWIPE_LEFT
		{GLYPH_SWIPE_LEFT_HOLD,GLYPH_SWIPE_LEFT_MASK}, // OVERLAY_SWIPE_LEFT_HOLD
		{GLYPH_SWIPE_UP,GLYPH_SWIPE_UP_MASK}, // OVERLAY_SWIPE_UP
		{GLYPH_SWIPE_UP_HOLD,GLYPH_SWIPE_UP_MASK}, // OVERLAY_SWIPE_UP_HOLD
		{GLYPH_SWIPE_DOWN,GLYPH_SWIPE_DOWN_MASK}, // OVERLAY_SWIPE_DOWN
		{GLYPH_SWIPE_DOWN_HOLD,GLYPH_SWIPE_DOWN_MASK}, // OVERLAY_SWIPE_DOWN_HOLD
		{GLYPH_CLICK,GLYPH_CLICK_MASK}, // OVERLAY_CLICK
		{GLYPH_CLICK_HOLD,GLYPH_CLICK_MASK}, // OVERLAY_CLICK_HOLD
		{GLYPH_DOUBLE_CLICK,GLYPH_CLICK_MASK}, // OVERLAY_DOUBLE_CLICK
		{GLYPH_SLEEP,GLYPH_SLEEP_MASK} // OVERLAY_SLEEP
	};
#endif // ifndef USE_SMALL_ICONS

// "Glyphs" are graphics/icons that can be placed at various locations on the sensor
// When placing a glyph it is possible to place a subset of the glyph at a location
// this allows us to have a font in a single glyph.
// Comments in-line are (offset) NAME (dimensions) = size
// Small Icon Set
#ifdef USE_SMALL_ICONS
	ROM_DATA BYTE glyphData[] = {
		// (0) GLYPH_FONT (128 x 24) = 384 bytes
		0x00,0x00,0x00,0x00,0x00,0x2E,0x00,0x00,0x06,0x00,0x06,0x00,0x3E,0x14,0x3E,0x00,0x14,0x3E,0x0A,0x00,0x12,0x08,0x24,0x00,0x1E,0x2E,0x38,0x00,0x00,0x06,0x00,0x00,
		0x00,0x1C,0x22,0x00,0x22,0x1C,0x00,0x00,0x0A,0x04,0x0A,0x00,0x08,0x1C,0x08,0x00,0x20,0x10,0x00,0x00,0x08,0x08,0x08,0x00,0x00,0x20,0x00,0x00,0x30,0x08,0x06,0x00,
		0x3C,0x22,0x1E,0x00,0x04,0x3E,0x00,0x00,0x32,0x2A,0x24,0x00,0x22,0x2A,0x14,0x00,0x0E,0x08,0x3E,0x00,0x2E,0x2A,0x12,0x00,0x3C,0x2A,0x3A,0x00,0x32,0x0A,0x06,0x00,
		0x3E,0x2A,0x3E,0x00,0x2E,0x2A,0x1E,0x00,0x00,0x14,0x00,0x00,0x20,0x14,0x00,0x00,0x08,0x14,0x22,0x00,0x14,0x14,0x14,0x00,0x22,0x14,0x08,0x00,0x02,0x2A,0x06,0x00,
		0x1C,0x2A,0x2C,0x00,0x3C,0x0A,0x3C,0x00,0x3E,0x2A,0x14,0x00,0x1C,0x22,0x22,0x00,0x3E,0x22,0x1C,0x00,0x3E,0x2A,0x2A,0x00,0x3E,0x0A,0x0A,0x00,0x1C,0x2A,0x3A,0x00,
		0x3E,0x08,0x3E,0x00,0x22,0x3E,0x22,0x00,0x10,0x20,0x1E,0x00,0x3E,0x08,0x36,0x00,0x3E,0x20,0x20,0x00,0x3E,0x0C,0x3E,0x00,0x3E,0x1C,0x3E,0x00,0x1C,0x22,0x1C,0x00,
		0x3E,0x0A,0x04,0x00,0x1C,0x32,0x3C,0x00,0x3E,0x1A,0x2C,0x00,0x24,0x2A,0x12,0x00,0x02,0x3E,0x02,0x00,0x1E,0x20,0x3E,0x00,0x0E,0x30,0x0E,0x00,0x3E,0x18,0x3E,0x00,
		0x36,0x08,0x36,0x00,0x06,0x38,0x06,0x00,0x32,0x2A,0x26,0x00,0x3E,0x22,0x22,0x00,0x04,0x08,0x10,0x00,0x22,0x22,0x3E,0x00,0x04,0x02,0x04,0x00,0x20,0x20,0x20,0x00,
		0x02,0x04,0x00,0x00,0x34,0x2C,0x38,0x00,0x3E,0x24,0x18,0x00,0x18,0x24,0x24,0x00,0x18,0x24,0x3E,0x00,0x18,0x34,0x2C,0x00,0x08,0x3C,0x0A,0x00,0x18,0x54,0x3C,0x00,
		0x3E,0x04,0x38,0x00,0x00,0x3A,0x00,0x00,0x20,0x40,0x3A,0x00,0x3E,0x18,0x24,0x00,0x22,0x3E,0x20,0x00,0x3C,0x1C,0x3C,0x00,0x3C,0x04,0x38,0x00,0x18,0x24,0x18,0x00,
		0x7C,0x24,0x18,0x00,0x18,0x24,0x7C,0x00,0x38,0x04,0x04,0x00,0x28,0x3C,0x14,0x00,0x04,0x3E,0x24,0x00,0x1C,0x20,0x3C,0x00,0x1C,0x30,0x1C,0x00,0x3C,0x38,0x3C,0x00,
		0x24,0x18,0x24,0x00,0x0C,0x50,0x3C,0x00,0x34,0x3C,0x2C,0x00,0x08,0x36,0x22,0x00,0x00,0x36,0x00,0x00,0x22,0x36,0x08,0x00,0x04,0x06,0x02,0x00,0x3E,0x3E,0x3E,0x00,
		// (384) GLYPH_SMILE, GLYPH_FROWN, GLYPH_HATCH, GLYPH_GHOST, GLYPH_FACE_MASK, GLYPH_GHOST_MASK = 44 bytes
		0x3C,0x42,0x95,0xA1,0xA1,0x95,0x42,0x3C,0x3C,0x42,0xA5,0x91,0x91,0xA5,0x42,0x3C,0x24,0x49,0x92,0x24,0x49,0x92,0x24,0x49,0xFE,0x41,0x8D,0x4D,0x81,0x7E,0xC3,0x81,
		0x00,0x00,0x00,0x00,0x81,0xC3,0x01,0x80,0x00,0x80,0x00,0x81,
		// (428) GLYPH_SWIPE_RIGHT (16 x 16) = 32 bytes
		0x00,0x00,0xE0,0x20,0x20,0x20,0x20,0x20,0x3C,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x03,0x02,0x02,0x02,0x02,0x02,0x1E,0x18,0x0C,0x06,0x03,0x01,0x00,0x00,
		// (460) GLYPH_SWIPE_RIGHT_HOLD (16 x 16) = 32 bytes
		0x00,0x00,0xE0,0x60,0xE0,0x60,0xE0,0x60,0xFC,0x6C,0xD8,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x1F,0x1B,0x0D,0x06,0x03,0x01,0x00,0x00,
		// (492) GLYPH_SWIPE_RIGHT_MASK (16 x 16) = 32 bytes
		0xFF,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x00,0x00,0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0xFF,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0x80,0x80,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,
		// (524) GLYPH_SWIPE_LEFT (16 x 16) = 32 bytes
		0x00,0x00,0x80,0xC0,0x60,0x30,0x18,0x0C,0x3C,0x20,0x20,0x20,0x20,0x20,0xE0,0x00,0x00,0x00,0x00,0x01,0x03,0x06,0x0C,0x18,0x1E,0x02,0x02,0x02,0x02,0x02,0x03,0x00,
		// (556) GLYPH_SWIPE_LEFT_HOLD (16 x 16) = 32 bytes
		0x00,0x00,0x80,0xC0,0x60,0x30,0xD8,0x6C,0xFC,0x60,0xE0,0x60,0xE0,0x60,0xE0,0x00,0x00,0x00,0x00,0x01,0x03,0x06,0x0D,0x1B,0x1F,0x03,0x03,0x03,0x03,0x03,0x03,0x00,
		// (588) GLYPH_SWIPE_LEFT_MASK (16 x 16) = 32 bytes
		0xFF,0x3F,0x1F,0x0F,0x07,0x03,0x01,0x00,0x00,0x00,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x80,0x80,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,
		// (620) GLYPH_SWIPE_UP (16 x 16) = 32 bytes
		0x00,0x00,0x00,0xC0,0xE0,0xB0,0x98,0x0C,0x06,0x0C,0x98,0xB0,0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x20,0x20,0x20,0x3F,0x00,0x00,0x00,0x00,0x00,
		// (652) GLYPH_SWIPE_UP_HOLD (16 x 16) = 32 bytes
		0x00,0x00,0x00,0xC0,0xE0,0xB0,0xD8,0xEC,0xA6,0xEC,0xD8,0xB0,0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x3F,0x2A,0x3F,0x3F,0x00,0x00,0x00,0x00,0x00,
		// (684) GLYPH_SWIPE_UP_MASK (16 x 16) = 32 bytes
		0xFF,0x3F,0x1F,0x0F,0x07,0x03,0x01,0x00,0x00,0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0xFF,0xFE,0xFE,0xFE,0xFE,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFE,0xFE,0xFE,0xFE,
		// (716) GLYPH_SWIPE_DOWN (16 x 16) = 32 bytes
		0x00,0x00,0x00,0x80,0x80,0x80,0xFE,0x02,0x02,0x02,0xFE,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x06,0x0C,0x18,0x30,0x18,0x0C,0x06,0x03,0x01,0x00,0x00,
		// (748) GLYPH_SWIPE_DOWN_HOLD (16 x 16) = 32 bytes
		0x00,0x00,0x00,0x80,0x80,0x80,0xFE,0xFE,0xAA,0xFE,0xFE,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x06,0x0D,0x1B,0x32,0x1B,0x0D,0x06,0x03,0x01,0x00,0x00,
		// (780) GLYPH_SWIPE_DOWN_MASK (16 x 16) = 32 bytes
		0xFF,0x3F,0x3F,0x3F,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x3F,0x3F,0x3F,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x80,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,
		// (812) GLYPH_CLICK (16 x 16) = 32 bytes
		0x00,0x00,0x00,0x00,0x00,0xF0,0x08,0xF0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x14,0x24,0x48,0x87,0x00,0x07,0x00,0x07,0x01,0x06,0x82,0x7C,0x00,0x00,
		// (844) GLYPH_CLICK_HOLD (16 x 16) = 32 bytes
		0x00,0x00,0x00,0x00,0x00,0xF0,0xF8,0xF0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x1C,0x3C,0x78,0xFF,0xFF,0xFF,0xFC,0xFF,0xF9,0xFE,0xF2,0x7C,0x00,0x00,
		// (876) GLYPH_CLICK_MASK (16 x 16) = 32 bytes
		0xFF,0xFF,0xFF,0xFF,0x0F,0x07,0x03,0x07,0x0F,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xF7,0xE3,0xC1,0x81,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x83,0xFF,
		// (908) GLYPH_DOUBLE_CLICK (16 x 16) = 32 bytes
		0x00,0x00,0x1C,0x22,0x5D,0xF2,0x0A,0xF2,0xDD,0x22,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x14,0x24,0x48,0x87,0x00,0x07,0x00,0x07,0x01,0x06,0x82,0x7C,0x00,0x00,
		// (940) GLYPH_DOUBLE_CLICK_MASK (16 x 16) = 32 bytes
		0xFF,0xE3,0xC1,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x41,0xE3,0xFF,0xFF,0xFF,0xFF,0xF7,0xE3,0xC1,0x81,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x83,0xFF,
		// (972) GLYPH_SLEEP (16 x 16) = 32 bytes
		0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x10,0x90,0x70,0x30,0x00,0x32,0x2A,0x26,0x00,0x00,0x71,0x79,0x7F,0x67,0x63,0x00,0x03,0x03,0x02,0x02,0x00,0x00,0x00,0x00,0x00,
		// (1004) GLYPH_SLEEP_MASK (16 x 16) = 32 bytes
		0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x07,0x47,0x07,0x07,0x87,0x88,0x80,0x80,0x80,0x88,0x0C,0x04,0x00,0x00,0x00,0x08,0x08,0xF8,0xF8,0xF8,0xF8,0xF8,0xFF,0xFF,0xFF,0xFF,
		// (1036) GLYPH_HEX_FONT (64 x 8) = 64 bytes
		0x3C,0x22,0x1E,0x00,0x04,0x3E,0x00,0x00,0x32,0x2A,0x24,0x00,0x22,0x2A,0x14,0x00,0x0E,0x08,0x3E,0x00,0x2E,0x2A,0x12,0x00,0x3C,0x2A,0x3A,0x00,0x32,0x0A,0x06,0x00,
		0x3E,0x2A,0x3E,0x00,0x2E,0x2A,0x1E,0x00,0x3C,0x0A,0x3C,0x00,0x3E,0x2A,0x14,0x00,0x1C,0x22,0x22,0x00,0x3E,0x22,0x1C,0x00,0x3E,0x2A,0x2A,0x00,0x3E,0x0A,0x0A,0x00
	};


	// Information on the glyphs in glyphData.  Each instance of the structure contains
	// {X dimension, Y dimension, offset}
	ROM_DATA GLYPHINFO glyphInfo[] = {
		{128, 24, 0}, // GLYPH_FONT
		{8, 8, 384}, // GLYPH_SMILE
		{8, 8, 392}, // GLYPH_FROWN
		{4, 16, 400}, // GLYPH_HATCH
		{6, 8, 408}, // GLYPH_GHOST
		{8, 8, 414}, // GLYPH_FACE_MASK
		{6, 8, 422}, // GLYPH_GHOST_MASK
		{16, 16, 428}, // GLYPH_SWIPE_RIGHT
		{16, 16, 460}, // GLYPH_SWIPE_RIGHT_HOLD
		{16, 16, 492}, // GLYPH_SWIPE_RIGHT_MASK
		{16, 16, 524}, // GLYPH_SWIPE_LEFT
		{16, 16, 556}, // GLYPH_SWIPE_LEFT_HOLD
		{16, 16, 588}, // GLYPH_SWIPE_LEFT_MASK
		{16, 16, 620}, // GLYPH_SWIPE_UP
		{16, 16, 652}, // GLYPH_SWIPE_UP_HOLD
		{16, 16, 684}, // GLYPH_SWIPE_UP_MASK
		{16, 16, 716}, // GLYPH_SWIPE_DOWN
		{16, 16, 748}, // GLYPH_SWIPE_DOWN_HOLD
		{16, 16, 780}, // GLYPH_SWIPE_DOWN_MASK
		{16, 16, 812}, // GLYPH_CLICK
		{16, 16, 844}, // GLYPH_CLICK_HOLD
		{16, 16, 876}, // GLYPH_CLICK_MASK
		{16, 16, 908}, // GLYPH_DOUBLE_CLICK
		{16, 16, 940}, // GLYPH_DOUBLE_CLICK_MASK
		{16, 16, 972}, // GLYPH_SLEEP
		{16, 16, 1004}, // GLYPH_SLEEP_MASK
		{64, 8, 1036} // GLYPH_HEX_FONT
	};

	// When overlaying data, what combination of graphic and mask is needed?
	// {Graphic Glyph, Mask Glyph}
	// A mask glyph identifies which areas to retain when drawing on an area.
	ROM_DATA GLYPHSET glyphSet[] = {
		{0,0}, // OVERLAY_NONE
		{GLYPH_SWIPE_RIGHT,GLYPH_SWIPE_RIGHT_MASK}, // OVERLAY_SWIPE_RIGHT
		{GLYPH_SWIPE_RIGHT_HOLD,GLYPH_SWIPE_RIGHT_MASK}, // OVERLAY_SWIPE_RIGHT_HOLD
		{GLYPH_SWIPE_LEFT,GLYPH_SWIPE_LEFT_MASK}, // OVERLAY_SWIPE_LEFT
		{GLYPH_SWIPE_LEFT_HOLD,GLYPH_SWIPE_LEFT_MASK}, // OVERLAY_SWIPE_LEFT_HOLD
		{GLYPH_SWIPE_UP,GLYPH_SWIPE_UP_MASK}, // OVERLAY_SWIPE_UP
		{GLYPH_SWIPE_UP_HOLD,GLYPH_SWIPE_UP_MASK}, // OVERLAY_SWIPE_UP_HOLD
		{GLYPH_SWIPE_DOWN,GLYPH_SWIPE_DOWN_MASK}, // OVERLAY_SWIPE_DOWN
		{GLYPH_SWIPE_DOWN_HOLD,GLYPH_SWIPE_DOWN_MASK}, // OVERLAY_SWIPE_DOWN_HOLD
		{GLYPH_CLICK,GLYPH_CLICK_MASK}, // OVERLAY_CLICK
		{GLYPH_CLICK_HOLD,GLYPH_CLICK_MASK}, // OVERLAY_CLICK_HOLD
		{GLYPH_DOUBLE_CLICK,GLYPH_DOUBLE_CLICK_MASK}, // OVERLAY_DOUBLE_CLICK
		{GLYPH_SLEEP,GLYPH_SLEEP_MASK} // OVERLAY_SLEEP
	};
#endif // #ifdef USE_SMALL_ICONS

// This contains all of the constant strings used by the display.
// see the "stringInfo" structure for how they are identified
ROM_DATA BYTE stringData[] = "    r1.312/06/19Touch Sensor to Continue";

// This structure identifies the offset within stringData for a specific string
ROM_DATA int stringInfo[] = {
	0, // STRING_VERSION
	8, // STRING_DATE
	16,  // STRING_TOUCH
	40// <end>
};

// "Private" Functions:
// These should never be called outside this file.
void inline lcdBegin(LCD_MODE mode);
void inline lcdEnd(void);
void lcdBufferBlit(void);

/*************************************************************************//**
* Function:        	void lcdInit(LCDINIT_TYPE initType)
*
* \pre		    	None
*
* \result
*
* \post		    	None
*
* \brief        	Initializes the lcd.
*
* \note           	None
*
*****************************************************************************/
void lcdInit(LCD_INIT_TYPE initType)
{
	lcdBegin(LCD_CONTROL);
		sendSPIstring(lcdInitString,14);
	lcdEnd();
	lcdSetOverlay(OVERLAY_NONE,0);
	if (initType == INIT_FULL)
	{
		unsigned char x = 0;
		lcdBuffer.guiState = UI_INIT;
		lcdBufferClear(CLEAR_BLANK);
		for (x = 0; x < 16; x++)
		{
			lcdBuffer.changed[x] = 0;
			lcdBuffer.map[x] = 0;
		}
	}
}


/*************************************************************************//**
* Function:        	void lcdTest(void)
*
* \pre		    	None
*
* \result
*
* \post		    	None
*
* \brief        	Test function that exercises some lcd functionality not
*					called during normal operation
*
* \note           	None
*
*****************************************************************************/
void lcdTest(void)
{
	unsigned char direction = 1;
	unsigned char x = 0;
	lcdBuffer.guiGlyphOverlay = GLYPH_SWIPE_RIGHT;
	lcdBuffer.guiGlyphMask = GLYPH_SWIPE_RIGHT_MASK;
	lcdBufferClear(CLEAR_LOGO);
	lcdBufferBlit();

	//delay1ms(1000);

	//delay100usTMR(10000);



	//lcdBufferClear(CLEAR_BLANK);
	//lcdBufferBlit();
	direction = 0;
	for (;;)
	{
		//lcdPutLine(0,0,x,63,COLOR_INVERT);  // good
		lcdPutLine(63,0,0,x,COLOR_INVERT);



		//lcdPutLine(128,0,x,64,COLOR_BLACK);
		//lcdPutLine(128,64,x,0,COLOR_BLACK);
		//lcdPutStringRaw("Line Test",9,46,24,GLYPH_COPY);
		//lcdPutString(STRING_TOUCH,10,8,GLYPH_COPY);
		//lcdPutLine(96,32,56,x+8,COLOR_BLACK);
		/*switch (direction)
		{
			case 0:
				lcdPutLine(96,32,56,x+8,COLOR_BLACK);
				break;
			case 1:
				lcdPutLine(96,32,56+x,55,COLOR_BLACK);
				break;
			case 2:
				lcdPutLine(96,32,119,55-x,COLOR_BLACK);
				break;
			case 3:
				lcdPutLine(96,32,119-x,8,COLOR_BLACK);
				break;
		}*/
		//lcdPutStringRaw("abcdefghijklmnopqrstuvwxyz",26,0,0,GLYPH_COPY);
		//lcdPutStringRaw("ABCDEFGHIJKLMNOPQRSTUVWXYZ",26,0,8,GLYPH_COPY);
		//lcdPutStringRaw("0123456789",10,0,16,GLYPH_COPY);
		//lcdPutHexValue(direction,0,24);
		lcdPutHexValue(x,0,32);
		//#define sgn(x) ((x<0)?-1:((x>0)?1:0))
		//#define abs(x) ((x<0)?(-x):x)

		/*if (abs(15) == 15)
		{
			lcdPutHexValue(15,8,0);
		}
		if (abs(-15) == 15)
		{
			lcdPutHexValue(15,8,8);
		}
		if (sgn(1) == 1)
		{
			lcdPutHexValue(1,16,0);
		}
		if (sgn(0) == 0)
		{
			lcdPutHexValue(1,16,4);
		}
		if (sgn(-1) == -1)
		{
			lcdPutHexValue(1,16,8);
		}*/

		lcdBufferBlit();
		/*switch (direction) // erase it
		{
			case 0:
				lcdPutLine(96,32,56,x+8,COLOR_BLACK);
				break;
			case 1:
				lcdPutLine(96,32,56+x,55,COLOR_BLACK);
				break;
			case 2:
				lcdPutLine(96,32,119,55-x,COLOR_BLACK);
				break;
			case 3:
				lcdPutLine(96,32,119-x,8,COLOR_BLACK);
				break;
		}*/
		x++;
		if (x>= 64)
		{
			direction++;
			if (direction > 3)
			{
				direction = 0;
			}
			x = 0;
		}
		delay1ms(100);
	}



	for (;;)
	{
		//delay1ms(250);
	//	delay100usTMR(2500);
		lcdBufferClear(CLEAR_LOGO);
		lcdPutGlyph(GLYPH_FONT,0,0,0,0,0,0,GLYPH_COPY);
		//lcdPutString(STRING_VERSION,96,0,GLYPH_COPY);
		//lcdPutString(STRING_DATE,96,8,GLYPH_COPY);
		/*lcdPutPoint(x<<1,x,COLOR_INVERT);*/
		//lcdPutGlyph(GLYPH_GHOST_MASK,x,0,0,0,0,0,GLYPH_AND);
		if (direction)
		{
			x++;
		}
		else
		{
			x--;
		}
		lcdPutGlyph(GLYPH_SWIPE_RIGHT_MASK,x,24,0,0,0,0,GLYPH_AND);
		lcdPutGlyph(GLYPH_SWIPE_RIGHT,x,24,0,0,0,0,GLYPH_OR);
		if (x>(128-glyphInfo[GLYPH_SWIPE_RIGHT].width))
		{
			direction = 0;
		}
		if (x == 0)
		{
			direction = 1;
		}
		//lcdPutStringRaw("abcdefghijklmnopqrstuvwxyz",26,0,0,GLYPH_COPY);
		//lcdPutStringRaw("ABCDEFGHIJKLMNOPQRSTUVWXYZ",26,0,8,GLYPH_COPY);
		//lcdPutStringRaw("0123456789",10,0,16,GLYPH_COPY);
		lcdBufferBlit();
	}
}



/*************************************************************************//**
* Function:        	unsigned char lcdBegin(unsigned char mode)
*
* \pre		    	None
*
* \result
*
* \post		    	None
*
* \brief        	We are starting a sequence of LCD Commands
*
* \note           	None
*
*****************************************************************************/
void inline lcdBegin(LCD_MODE mode)
{
	SPI_CS = 0;
	LCD_A0 = mode;
}

/*************************************************************************//**
* Function:        	unsigned char lcdEnd(void)
*
* \pre		    	None
*
* \result
*
* \post		    	None
*
* \brief        	We are done with a sequence of LCD Commands.  Waits for
*					all bytes to be transmitted, then sets SPI_CS
*
* \note           	None
*
*****************************************************************************/
void inline lcdEnd(void)
{
	waitOnSPITX();
	SPI_CS = 1;
}

/*************************************************************************//**
* Function:        	void lcdSetGUIState(LCD_UI_STATE guiState)
*
* \pre		    	None
*
* \result
*
* \post		    	None
*
* \brief        	Sets the GUI State on the display
*
* \note           	None
*
*****************************************************************************/
void lcdSetGUIState(LCD_UI_STATE guiState)
{
	if (guiState != lcdBuffer.guiState)
	{
		switch (guiState)
		{
			case UI_INIT: // Very beginning initialization, blank screen
				lcdBufferClear(CLEAR_BLANK);
				break;
			case UI_STARTUP: // Startup screen, includes date and version info
				lcdSetOverlay(OVERLAY_NONE,0);
				lcdBufferClear(CLEAR_LOGO);
				lcdPutString(STRING_VERSION,96,8,GLYPH_COPY);
				lcdPutString(STRING_DATE,96,0,GLYPH_COPY);
				break;
			case UI_LOGO: // simple logo screen
				lcdSetOverlay(OVERLAY_NONE,0);
				lcdBufferClear(CLEAR_LOGO);
				lcdPutString(STRING_TOUCH,16,40,GLYPH_COPY);
				break;
			case UI_DRAW: // drawing screen (with "map" in the corner)
				lcdBufferClear(CLEAR_BLANK);
				lcdPutLine(0,8,16,8,COLOR_BLACK);
				lcdPutLine(16,0,16,8,COLOR_BLACK);
				break;
			case UI_CLEARSCREEN: // clearing the drawing screen
				lcdBufferClear(CLEAR_BLANK);
				break;
		};
		lcdBuffer.guiState = guiState;
	}
}

/*************************************************************************//**
* Function:        	unsigned char lcdSetOverlay(LCD_OVERLAY_ID overlayID)
*
* \pre		    	None
*
* \result
*
* \post		    	None
*
* \brief        	Sets the Overlay Graphic on the LCD
*
* \note           	None
*
*****************************************************************************/
void lcdSetOverlay(LCD_OVERLAY_ID overlayID, int timeout)
{
	lcdBuffer.guiGlyphOverlay = glyphSet[overlayID].ID;
	lcdBuffer.guiGlyphMask = glyphSet[overlayID].mask;
	lcdBuffer.guiGlyphTimer = timeout;
	if (overlayID == GLYPH_NONE)
	{
		lcdBuffer.guiGlyphState = GS_WAIT;
	}
	else
	{
		lcdBuffer.guiGlyphState = GS_DRAW;
	}
}

/*************************************************************************//**
* Function:        	unsigned char lcdBufferBlit(void)
*
* \pre		    	None
*
* \result
*
* \post		    	None
*
* \brief        	copies the contents of the display buffer to the LCD in an
*					optimized manner.  Additionally draws the overlay glyph
*					and the "map".
*
* \note           	None
*
*****************************************************************************/
void lcdBufferBlit(void)
{
	unsigned char x,y;
	unsigned char tCount[2] = {'0'+touchIDSet.touchCount,0};
	BYTE tMask = 0;
	//unsigned char doOverlay = (lcdBuffer.guiGlyphTimer > 0);
	if (lcdBuffer.guiGlyphState)
	{
		// copy from buffer to guiTemp
		for (y = 0; y < 2; y++)
		{
			for (x = 0; x < 16; x++)
			{
				guiTemp[y][x] = lcdBuffer.lcdData[y+OVERLAY_POSITION_Y][x+OVERLAY_POSITION_X];
			}
		}
		// mask in gui Element
		lcdPutGlyph(lcdBuffer.guiGlyphMask, OVERLAY_POSITION_X, OVERLAY_POSITION_Y, 0, 0, 0, 0, GLYPH_AND);
		// draw gui Element
		lcdPutGlyph(lcdBuffer.guiGlyphOverlay, OVERLAY_POSITION_X, OVERLAY_POSITION_Y, 0, 0, 0, 0, GLYPH_OR);
	}
	if (lcdBuffer.guiState == UI_DRAW || lcdBuffer.guiState == UI_CLEARSCREEN)
	{
		lcdPutStringRaw(tCount,1,18,0,GLYPH_COPY);
	}

	// Optimized drawing routine
	for (y = 0; y < 8; y++)
	{
		BYTE groupSize = 0;
		tMask = 0x01<<y;
		for (x = 0; x < 16; x++)
		{
			if (lcdBuffer.changed[x]&tMask)
			{
				while (x+groupSize < 16 && lcdBuffer.changed[x+groupSize]&tMask)
				{
					groupSize++;
				}
				// the current block has changed
				lcdBegin(LCD_CONTROL);
					sendSPIchar(0x10 | x>>1);  // low 4: col MSB
					sendSPIchar(0x00 | (x&0x01)<<3);  // low 4: col LSB
					sendSPIchar(0xB0+y);
				lcdEnd();
				lcdBegin(LCD_DISPLAY);
					sendSPIstring(lcdBuffer.lcdData[y]+(x<<3),groupSize<<3);
				lcdEnd();

			}
		}
	}

/*
	// draw the entire sensor in the most basic way (don't used optimization)
	for (y = 0; y < 8; y++)
	{
		lcdBegin(LCD_CONTROL);
			sendSPIchar(0x10);  // low 4: col MSB
			sendSPIchar(0x00);  // low 4: col LSB
			sendSPIchar(0xB0+y);
		lcdEnd();
		lcdBegin(LCD_DISPLAY);
			sendSPIstring(lcdBuffer.lcdData[y],128);
		lcdEnd();
	}
*/

	// Draw the "Map"


	lcdBegin(LCD_CONTROL);
		sendSPIchar(0x10);  // low 4: col MSB
		sendSPIchar(0x00);  // low 4: col LSB
		sendSPIchar(0xB0);
	lcdEnd();
	lcdBegin(LCD_DISPLAY);
		sendSPIstring(lcdBuffer.map,16);
	lcdEnd();

	for (x = 0; x < 16; x++)
	{
			lcdBuffer.changed[x] = 0;
			lcdBuffer.map[x] = 0;
	}

	// End Diagnostics


	if (lcdBuffer.guiGlyphState)
	{
			// copy from guiTemp to buffer
		for (y = 0; y < 2; y++)
		{
			for (x = 0; x < 16; x++)
			{
				lcdBuffer.lcdData[y+OVERLAY_POSITION_Y][x+OVERLAY_POSITION_X] = guiTemp[y][x];
			}
		}

		if (lcdBuffer.guiGlyphState == GS_CLEAR)
		{
			for (x = 12; x < 16; x++)
			{
				lcdBuffer.changed[x] |= 0x0F;
			}
			lcdBuffer.guiGlyphState = GS_WAIT;
		}
	}
}

/*************************************************************************//**
* Function:        	unsigned char lcdBufferClear(void)
*
* \pre		    	None
*
* \result
*
* \post		    	None
*
* \brief        	clears the screen buffer - either to "blank", inverted,
*					or the Microchip logo
*
* \note           	None
*
*****************************************************************************/
void lcdBufferClear(LCD_CLEAR_TYPE type)
{
	unsigned char x, y;
	if (type == CLEAR_BLANK)
	{
		for (x = 0; x < 8; x++)
		{
			for (y = 0; y < 128; y++)
			{
				lcdBuffer.lcdData[x][y] = 0;
			}
		}
	}
	else if (type == CLEAR_INVERT)
	{
		for (x = 0; x < 8; x++)
		{
			for (y = 0; y < 128; y++)
			{
				lcdBuffer.lcdData[x][y] = lcdBuffer.lcdData[x][y]^0xff;
			}
		}
	}
	else if (type == CLEAR_LOGO)
	{
		for (x = 0; x < 8; x++)
		{
			for (y = 0; y < 128; y++)
			{
				lcdBuffer.lcdData[x][y] = lcdBaseScreen[x][y];
			}
		}
	}
	for (x = 0; x < 16; x++)
	{
		lcdBuffer.changed[x] = 0xff;
	}
}

/*************************************************************************//**
* Function:        	void lcdPutPoint(BYTE x, BYTE y, LCD_COLOR color)
*
* \pre		    	None
*
* \result
*
* \post		    	None
*
* \brief        	sets the pixel at x,y to color (BLACK, WHITE, INVERTED)
*
* \note           	None
*
*****************************************************************************/
void lcdPutPoint(BYTE x, BYTE y, LCD_COLOR color)
{
	if (color == COLOR_BLACK)
	{
		lcdBuffer.lcdData[y>>3][x] |= (1 << (y&0x07));
	}
	else if (color == COLOR_WHITE)
	{
		lcdBuffer.lcdData[y>>3][x] &= (0xff^(1 << (y&0x07)));
	}
	else if (color == COLOR_INVERT)
	{
		lcdBuffer.lcdData[y>>3][x] ^= (1 << (y&0x07));
	}
	//lcdBuffer.changed[y>>3] |= 0x01<<(x>>4);
	lcdBuffer.changed[x>>3] |= 0x01<<(y>>3);
	lcdBuffer.map[x>>3] |= 0x01<<(y>>3);
}

/*************************************************************************//**
* Function:        	void lcdPutLine(BYTE x1, BYTE y1, BYTE x2, BYTE y2, LCD_COLOR color)
*
* \pre		    	None
*
* \result
*
* \post		    	None
*
* \brief        	draws a line from x1,y1 to x2,y2
*
* \note           	None
*
*****************************************************************************/
void lcdPutLine(BYTE x1, BYTE y1, BYTE x2, BYTE y2, LCD_COLOR color)
{
  signed char i,dx,dy,sdx,sdy,dxabs,dyabs,x,y,px,py;

  dx=x2-x1;      /* the horizontal distance of the line */
  dy=y2-y1;      /* the vertical distance of the line */
  dxabs=abs(dx);
  dyabs=abs(dy);
  sdx=sgn(dx);
  sdy=sgn(dy);
  x=dyabs>>1;
  y=dxabs>>1;
  px=x1;
  py=y1;

  lcdPutPoint(px,py,color);

  if (dxabs>=dyabs) /* the line is more horizontal than vertical */
  {
    for(i=0;i<dxabs;i++)
    {
      y+=dyabs;
      if (y>=dxabs)
      {
        y-=dxabs;
        py+=sdy;
      }
      px+=sdx;
      lcdPutPoint(px,py,color);
    }
  }
  else /* the line is more vertical than horizontal */
  {
    for(i=0;i<dyabs;i++)
    {
      x+=dxabs;
      if (x>=dyabs)
      {
        x-=dyabs;
        px+=sdx;
      }
      py+=sdy;
  	  lcdPutPoint(px,py,color);
    }
  }
}

/*************************************************************************//**
* Function:        	void lcdPutGlyph(LCD_GLYPH_ID glyphID, BYTE x, BYTE y, BYTE gx, BYTE gy, BYTE dx, BYTE dy, GLYPH_COPY_TYPE copyStyle)
*
* \pre		    	None
*
* \result
*
* \post		    	None
*
* \brief        	Places a segment of glyph glyphID at x, y in the buffer
*					gx, gy is the starting location on the glyph
*					dx, dy is the width and height to copy over
*					copyStyle selects the blit format - COPY, OR, AND, XOR
*
* \note           	Currently y locations and y dimensions MUST be multiples of 8
*
*****************************************************************************/
void lcdPutGlyph(LCD_GLYPH_ID glyphID, BYTE x, BYTE y, BYTE gx, BYTE gy, BYTE dx, BYTE dy, GLYPH_COPY_TYPE copyStyle)
{
	BYTE cx, cy; // current X, current Y
	int glyphStart = 0;
	//int glyphOffset = 0;
	if (dx == 0 || (dx+gx) > glyphInfo[glyphID].width)
	{
		dx = glyphInfo[glyphID].width-gx;
	}
	if (dy == 0 || (dy+gy) > glyphInfo[glyphID].height)
	{
		dy = glyphInfo[glyphID].height-gy;
	}
	for (cy = 0; cy < dy>>3; cy++)
	{
		glyphStart = cy+(gy>>3);
		glyphStart *= glyphInfo[glyphID].width;
		glyphStart += glyphInfo[glyphID].start + gx;
		//glyphStart = glyphInfo[glyphID].start + gx + ((cy+(gy>>3))*glyphInfo[glyphID].width);
		for (cx = 0; cx < dx; cx++)
		{
			switch (copyStyle)
			{
				case GLYPH_OR:
					lcdBuffer.lcdData[cy+(y>>3)][cx+x] |= glyphData[glyphStart+cx];
					break;
				case GLYPH_AND:
					lcdBuffer.lcdData[cy+(y>>3)][cx+x] &= glyphData[glyphStart+cx];
					break;
				case GLYPH_XOR:
					lcdBuffer.lcdData[cy+(y>>3)][cx+x] ^= glyphData[glyphStart+cx];
					break;
				case GLYPH_COPY:
				default:
					lcdBuffer.lcdData[cy+(y>>3)][cx+x] = glyphData[glyphStart+cx];
					break;
			};
			//lcdBuffer.changed[cy+(y>>3)] |= 0x01<<((cx+x)>>4);
			lcdBuffer.changed[(cx+x)>>3] |= 0x01<<(cy+(y>>3));
		}
	}
}

/*************************************************************************//**
* Function:        	BYTE lcdPutString(LCD_STRING_ID stringID, BYTE x, BYTE y, GLYPH_COPY_TYPE copyStyle)
*
* \pre		    	None
*
* \result 			returns the width of the string as displayed
*
* \post		    	None
*
* \brief        	Places string stringID at x, y in the buffer
*					copyStyle selects the blit format - COPY, OR, AND, XOR
*
* \note           	Currently y locations MUST be multiples of 8
*
*****************************************************************************/
BYTE lcdPutString(LCD_STRING_ID stringID, BYTE x, BYTE y, GLYPH_COPY_TYPE copyStyle)
{
	BYTE charID = 0;
	BYTE charLoc = 0;
	BYTE strSize = (stringInfo[stringID+1] - stringInfo[stringID]);
	int charOffset = stringInfo[stringID];
	// string from stringInfo[stringID] to stringInfo[stringID+1]

	for (charLoc = 0; charLoc < strSize; charLoc++)
	{
		charID = stringData[charOffset+charLoc];
		charID -= 32;
		lcdPutGlyph(GLYPH_FONT,x+(charLoc<<2),y,(charID&0x1F)<<2,(charID&0xE0)>>2,4,8,copyStyle);
	}
	return charLoc<<2;
}

BYTE lcdPutStringRaw(const unsigned char *buffer, unsigned char strSize, BYTE x, BYTE y, GLYPH_COPY_TYPE copyStyle)
{
	BYTE charID = 0;
	BYTE charLoc = 0;

	for (charLoc = 0; charLoc < strSize; charLoc++)
	{
		charID = buffer[charLoc];
		charID -= 32;
		lcdPutGlyph(GLYPH_FONT,x+(charLoc<<2),y,(charID&0x1F)<<2,(charID&0xE0)>>2,4,8,copyStyle);
	}
	return charLoc<<2;
}

void lcdPutHexValue(BYTE hexValue, BYTE x, BYTE y)
{
	BYTE tValue = (hexValue>>4)&0x0F;
	lcdPutGlyph(GLYPH_HEX_FONT,x,y,tValue<<2,0,4,8,GLYPH_COPY);
	tValue = hexValue&0x0F;
	lcdPutGlyph(GLYPH_HEX_FONT,x+4,y,tValue<<2,0,4,8,GLYPH_COPY);
}

/*************************************************************************//**
* Function:        	void addTouch(BYTE ID, BYTE x, BYTE y, BYTE state)
*
* \pre		    	None
*
* \result
*
* \post		    	None
*
* \brief			draws a given touch on the screen
*
* \note           	None
*
*****************************************************************************/
void addTouch(BYTE ID, BYTE x, BYTE y, BYTE state, TOUCH_DISPLAY_MODE displayMode)
{
	if (UI_LOGO == lcdBuffer.guiState)
	{
		lcdSetGUIState(UI_DRAW);
	}
	if (TDM_FULL == displayMode)
	{
		if (lcdBuffer.guiState != UI_CLEARSCREEN)
		{
			if (state == TS_TOUCH_DOWN)
			{
				touchLocs.Locs[ID].state = state;
				touchLocs.Locs[ID].loc[0].x = x;
				touchLocs.Locs[ID].loc[0].y = y;
				touchLocs.Locs[ID].loc[1].x = x;
				touchLocs.Locs[ID].loc[1].y = y;
				lcdPutPoint(touchLocs.Locs[ID].loc[0].x,touchLocs.Locs[ID].loc[0].y,COLOR_BLACK);
			}
			else if (state == TS_TOUCH_STREAM)
			{
				touchLocs.Locs[ID].state = state;
				touchLocs.Locs[ID].loc[1] = touchLocs.Locs[ID].loc[0];
				touchLocs.Locs[ID].loc[0].x = x;
				touchLocs.Locs[ID].loc[0].y = y;
				lcdPutLine(touchLocs.Locs[ID].loc[0].x,touchLocs.Locs[ID].loc[0].y,touchLocs.Locs[ID].loc[1].x,touchLocs.Locs[ID].loc[1].y,COLOR_BLACK);
			}
		}
	}
	else if (TDM_MAPONLY == displayMode)
	{
		lcdBuffer.map[x>>3] |= 0x01<<(y>>3);
	}
}

/*************************************************************************//**
* Function:        	void lcdFrame()
*
* \pre		    	None
*
* \result
*
* \post		    	None
*
* \brief			drives the lcd Screen, including state machines
*
* \note           	None
*
*****************************************************************************/
void lcdFrame(void)
{
	if (lcdBuffer.guiState == UI_CLEARSCREEN)
	{
		if (0 == touchIDSet.touchCount)
		{
			lcdSetGUIState(UI_DRAW);
		}
		else
		{
				lcdBufferClear(CLEAR_BLANK);
				lcdPutLine(0,8,16,8,COLOR_BLACK);
				lcdPutLine(16,0,16,8,COLOR_BLACK);
				lcdBufferBlit();
		}
	}
	lcdBufferBlit();
}

#endif // ifdef DISPLAY
